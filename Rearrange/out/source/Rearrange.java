/* autogenerated by Processing revision 1289 on 2023-01-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ipcapture.*;
import hypermedia.net.*;
import java.awt.*;
import processing.video.*;
import gab.opencv.*;
import java.awt.Frame;
import processing.awt.PSurfaceAWT;
import processing.awt.PSurfaceAWT.SmoothCanvas;
import gab.opencv.*;
import java.awt.Frame;
import processing.awt.PSurfaceAWT;
import processing.awt.PSurfaceAWT.SmoothCanvas;
import ipcapture.*;
import gab.opencv.*;
import java.awt.*;
import processing.video.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Rearrange extends PApplet {










//Herausgezogene wichtige Parameter des Systems
boolean TAUSCHE_ANTRIEB_LINKS_RECHTS = false;
float VORTRIEB = 0.7f;
float PROPORTIONALE_VERSTAERKUNG = 0.58f;
float INTEGRALE_VERSTAERKUNG = 0.15f;
float DIFFERENTIALE_VERSTAERKUNG = 0.1f;
float ASYMMETRIE = 1.01f; // 1.0==voll symmetrisch, >1, LINKS STAERKER, <1 RECHTS STAERKER

//VERSION FÜR TP-Link_59C2

//Zugriff auf Konfiguration:
//  http://tplinkwifi.net
//  ODER
//  http://192.168.0.1
//  ODER
//  http://192.168.1.1
//  PASSWORT FÜR ADMINISTRATION: TP-Link_59C2
//  EINRICHTUNG:
//  als Access Point
//  static IP
//  DHCP server enabled

//  Zugang zum access point:

//  hotspot
//  12345678

//  Fahrzeug Kramann: 192.168.0.102

String NACHRICHT = "";
//String TEMPERATUR = "";
//String IP = "192.168.137.92";
//String IP = "192.168.0.102";
String IP = "192.168.178.70";
int PORT = 6000;

//UDP udp;  // define the UDP object
UDPcomfort udpcomfort;  // define the UDP object
Antrieb antrieb;
IPCapture cam;
Bildverarbeitung bildverarbeitung;
Regler regler;

// Class for new window -> OpenCV Cascade
PWindow win;

// HSV Color Extraction
boolean yellow = false;
ColorHSV maskYellow;
PImage img, out1;

public void setup()
{
  /* size commented out by preprocessor */;
  cam = new IPCapture(this, "http://"+IP+":81/stream", "", "");
  cam.start();
  win = new PWindow(cam, 320, 0, 320, 240, "Cascade Detection");
  surface.setLocation(-5, 0);
  bildverarbeitung = new Bildverarbeitung();
  udpcomfort = new UDPcomfort(IP, PORT);
  antrieb = new Antrieb(udpcomfort);
  regler = new Regler(antrieb);
  frameRate(10);
}


boolean AKTIV = false;

public void draw()
{
  int[][] BILD;
  if(!yellow){
    //RGB only
    
    bildverarbeitung.extractColorRGB(cam);
    BILD = bildverarbeitung.getRed();
  }else{
    //HSV
    //Apply HSV Masking then compute the int [][] BILD value
    
    maskYellow = new ColorHSV("Yellow", cam);
    out1 = maskYellow.getMask(cam, true);
    bildverarbeitung.extractColorHSV(out1);
    BILD = bildverarbeitung.getYellow();
  }
  
  image(cam, 0, 0);
  float dx = (width/2.0f)/(float)BILD[0].length;
  float dy = (height/2.0f)/(float)BILD.length;
  noStroke();
  fill(200);
  rect(width/2, 0, width/2, height/2);
  fill(0);
  for (int i=0; i<BILD.length; i++)
  {
    for (int k=0; k<BILD[i].length; k++)
    {
      if (BILD[i][k]==0)
      {
        rect(width/2+(float)k*dx, 0+(float)i*dy, dx, dy);
      }
    }
  }

  boolean erfolg = regler.erzeugeStellsignalAusRotbild(BILD);

  if (erfolg)
  {
    float spx = regler.holeSchwerpunkt();
    stroke(255, 0, 0);
    strokeWeight(3.0f);
    line(width/2+(float)spx, 0, width/2+(float)spx, height/2);
  }

  fill(255);
  rect(0, height/2, width, height/2);
  fill(0);
  textSize(30);
  text(NACHRICHT, 20, height-height/3);
  text(udpcomfort.getTemperatur(), 20, height-height/6);

  fill(255, 0, 0);
  text((int)regler.getProzent()+"%"+" e="+regler.getRegeldifferenz(), 20, height-height/2);
}

public void keyPressed()
{
  if (key == ' ')
  {
    if (cam.isAlive())
    {
      cam.stop();
      NACHRICHT = "Kamera gestoppt";
    } else
    {
      cam.start();
      NACHRICHT = "Kamera gestartet";
    }
  } else if (key=='0') //stopp
  {
    antrieb.fahrt(0.0f, 0.0f);
    NACHRICHT = "Fahrt gestoppt";
    AKTIV=false;
  } else if (key=='1') //beide vor
  {
    antrieb.fahrt(1.0f, 1.0f);
    NACHRICHT = "Fahrt VORWÄRTS";
    AKTIV=true;
  } else if (key=='2') //beide rueck
  {
    antrieb.fahrt(-1.0f, -1.0f);
    NACHRICHT = "Fahrt RÜCKWÄRTS";
  } else if (key=='3') //links langsam vor
  {
    antrieb.fahrt(0.85f, 0.0f);
    NACHRICHT = "Fahrt LINKS langsam vor";
  } else if (key=='4') //rechts langsam vor
  {
    antrieb.fahrt(0.0f, 0.85f);
    NACHRICHT = "Fahrt RECHTS langsam vor";
  } else if (key=='5') //links langsam rück
  {
    antrieb.fahrt(-0.93f, 0.0f);
    NACHRICHT = "Fahrt LINKS langsam zurück";
  } else if (key=='6') //rechts langsam rück
  {
    antrieb.fahrt(0.0f, -0.93f);
    NACHRICHT = "Fahrt RECHTS langsam zurück";
  } else if (key=='7') //Kameralicht AN
  {
    udpcomfort.send(4, 1);
    NACHRICHT = "Kameralicht AN";
  } else if (key=='8') //Kameralicht AUS
  {
    udpcomfort.send(4, 0);
    NACHRICHT = "Kameralicht AUS";
  }
}

public void captureEvent(Capture c) {
  c.read();
}
public class Antrieb
{
  private UDPcomfort udpcomfort;
  public Antrieb(UDPcomfort udpcomfort)
  {
      this.udpcomfort = udpcomfort;
  }
  
   /**
         [-1,1]
     
    --------- PWM Motor -------------

    LINKS GRÜN | LINKS ROT | VCC | GND | RECHTS GRÜN | RECHTS ROT |
    ROT L 15   | AUS1 12   |     |     | GRÜN R 14   | AUS2 2     |

           
    VOR LINKS: L=0 AUS1=1
    RCK LINKS: L=1 AUS1=0

    VOR RECTS: R=0 AUS2=1
    RCK RECTS: R=1 AUS2=0
     
  */
  
//  public void fahrt( float rechts, float links)
  public void fahrt(float links, float rechts)
  {
    if(TAUSCHE_ANTRIEB_LINKS_RECHTS)
    {
        float h = links;
        links = rechts;
        rechts = h;
    }
    
    if(links>1.0f)   links  =  1.0f;
    if(links<-1.0f)  links  = -1.0f;
    if(rechts>1.0f)  rechts =  1.0f;
    if(rechts<-1.0f) rechts = -1.0f;
    
    if(links>=0.0f)
    {
        udpcomfort.send(0,255-(int)(links*255.0f));
        udpcomfort.send(2,1);
    }
    else
    {
        udpcomfort.send(0,(int)(-links*255.0f));
        udpcomfort.send(2,0);
    }
    
    if(rechts>=0.0f)
    {
        udpcomfort.send(1,255-(int)(rechts*255.0f));
        udpcomfort.send(3,1);
    }
    else
    {
        udpcomfort.send(1,(int)(-rechts*255.0f));
        udpcomfort.send(3,0);
    }    
  }
  
}


public class Bildverarbeitung
{
  int[][] bild = new int[240][320];
  int[][] bildOut = new int[240][320];
  int[][] bildR = new int[240][320];
  int[][] bildG = new int[240][320];
  int[][] bildB = new int[240][320];
  int[][] bildY = new int[240][320];
  int ANHEBUNG = 30;


  public Bildverarbeitung()
  {
  }

  private void computeColor(int [] pix) {
    //println("OKAY");
    int u=0;
    for (int i=0; i<bild.length; i++)
      for (int k=0; k<bild[i].length; k++)
        bild[i][k] = pix[u++];
    u=0;
    for (int i=0; i<bild.length; i++)
    {
      for (int k=0; k<bild[i].length; k++)
      {
        int wert = pix[u];

        // Using "right shift" as a faster technique than red(), green(), and blue()
        int ROT    = (wert  >> 8) & 0xFF;
        int GRUEN  = wert & 0xFF;
        int BLAU   = (wert >> 16) & 0xFF;

        bildR[i][k] = 2*ROT - GRUEN - BLAU + ANHEBUNG;
        if (bildR[i][k]<0) bildR[i][k]=-bildR[i][k];
        else bildR[i][k]=0;
        bildG[i][k] = 2*GRUEN - BLAU - ROT + ANHEBUNG;
        if (bildG[i][k]<0) bildG[i][k]=-bildG[i][k];
        else bildG[i][k]=0;
        bildB[i][k] = 2*BLAU - ROT - GRUEN + 35;
        if (bildB[i][k]<0) bildB[i][k]=-bildB[i][k];
        else bildB[i][k]=0;
        
        // Yellow = 50% R and 50% G
        int avg = (ROT + GRUEN)/2;
        bildY[i][k] = avg;

        u++;
      }
    }
  }

  //only when extracting non RGB
  
  public void extractColorRGB(IPCapture cam)
  {
    if (cam.isAvailable())
    {
      cam.read();
      //image(cam,0,0);
      cam.updatePixels();
      int[] pix = cam.pixels;
      if (pix!=null)
      {
        computeColor(pix);
      }
    }
  }

  // HSV Method
  public void extractColorHSV(PImage cam)
  {
    int[] pix = cam.pixels;
    if (pix!=null)
    {
      computeColor(pix);
    }
  }

  public int[][] getRed() {
    return bildR;
  }

  public int[][] getBlue() {
    return bildG;
  }

  public int[][] getGreen() {
    return bildB;
  }

  public int[][] getYellow() {
    return bildY;
  }
}
// only for yellow color detection
// but also useable for other colors which can be expanded

public class ColorHSV extends PApplet {

  private OpenCV opencv;
  private int hsvRange[][];
  private PImage maskHS, maskHSV;
  private PImage H, S, V;
  private HashMap<String, int[][]> hsvMap = new HashMap<String, int[][]>()
  {
    {
      put("Red1", new int[][]{{0, 50, 50}, {10, 255, 255}});
      put("Red2", new int[][]{{170, 50, 50}, {180, 255, 255}});
      put("Yellow", new int[][]{{25, 50, 70}, {35, 255, 255}});
      put("Green", new int[][]{{89, 255, 255}, {36, 50, 70}}); // not tested
      put("Blue", new int[][]{{90, 50, 70}, {128, 255, 255}});
    }
  };

  public ColorHSV(String type, PImage img) {
    this.opencv = new OpenCV(this, img);
    opencv.useColor(HSB);

    this.hsvRange = hsvMap.get(type);
  }

  public PImage getMask(PImage img, boolean withColor) {
    opencv.loadImage(img);

    opencv.setGray(opencv.getH().clone());
    opencv.inRange(hsvRange[0][0], hsvRange[1][0]);
    H = opencv.getSnapshot();

    opencv.setGray(opencv.getS().clone());
    opencv.inRange(hsvRange[0][1], hsvRange[1][1]);
    S = opencv.getSnapshot();

    opencv.diff(H);
    opencv.threshold(0);
    opencv.invert();
    maskHS = opencv.getSnapshot();

    opencv.setGray(opencv.getV().clone());
    opencv.inRange(hsvRange[0][2], hsvRange[1][2]);
    V = opencv.getSnapshot();

    opencv.diff(maskHS);
    opencv.threshold(0);
    opencv.invert();
    maskHSV = opencv.getSnapshot();
    if (!withColor) {
      return maskHSV;
    }

    PImage colorMask =createImage(maskHSV.width, maskHSV.height, RGB);

    for (int i = 0; i< maskHSV.width; i++) {
      for (int j=0; j< maskHSV.height; j++) {
        int c = maskHSV.get(i, j);
        int ori = img.get(i, j);
        if (c != -16777216) {
          colorMask.set(i, j, ori);
          continue;
        }
        colorMask.set(i, j, c);
      }
    }
    return colorMask;
  };

  public PImage combineMask(PImage mask2, PImage img) {
    PImage returnMask = createImage(maskHSV.width, maskHSV.height, RGB);
    for (int i = 0; i< maskHSV.width; i++) {
      for (int j=0; j< maskHSV.height; j++) {
        int c = maskHSV.get(i, j);
        int d = mask2.get(i, j);
        int ori = img.get(i, j);
        if (c != -16777216) {
          returnMask.set(i, j, ori);
          continue;
        } else if (d != -16777216) {
          returnMask.set(i, j, ori);
          continue;
        }
        returnMask.set(i, j, d);
      }
    }
    return returnMask;
  }

  public ArrayList<Contour> getContour() {
    return opencv.findContours(true, true);
  }

  public PImage getH() {
    return H;
  }
  public PImage getS() {
    return S;
  }
  public PImage getV() {
    return V;
  }
}
// This class serve as another window for Cascade Object Detection as it only detects when the window size is equal to the source size









class PWindow extends PApplet {

  OpenCV opencv;
  IPCapture cam;

  int x, y, w, h;
  boolean setLocation, setTitle, makeResizable;
  String title;


  // Method that should be called in this case
  PWindow(IPCapture cam, int x_, int y_, int ww, int hh, String s) {
    super();
    this.cam = cam;
    x = x_;
    y = y_;
    w = ww;
    h = hh;
    setLocation = true;
    title = s;
    setTitle = true;
    PApplet.runSketch(new String[] {this.getClass().getSimpleName()}, this);
  };

  public void settings() {
    if (w>0&&h>0)size(w, h);
    else size(320, 240);
  };

  public void setup() {
    frameRate(10);
    //if (setLocation)surface.setLocation(x, y);
    if (setTitle)surface.setTitle(title);
    //if (makeResizable)surface.setResizable(true);
    opencv = new OpenCV(this, this.cam);
    opencv.loadCascade("ball_detection.xml");
  };

  public void draw() {
    this.cam.read();
    opencv.loadImage(this.cam);
    Rectangle[] balls = this.detectObject();
    image(opencv.getInput(), 0, 0);
    noFill();
    stroke(0, 255, 0);
    strokeWeight(3);
    //println(balls.length);
    for (int i = 0; i < balls.length; i++) {
      //println(balls[i].x + "," + balls[i].y);
      rect(balls[i].x, balls[i].y, balls[i].width, balls[i].height);
    }
  };
  
  //get the bbox here
  public Rectangle[] detectObject() {
    Rectangle[] balls = opencv.detect(1.3f, 4, 0, 30, 300);
    return balls;
  }

};
/**
                       REGLER

CAM--->Segmentierung--->Schwerpunktsberechnung---->Stellsignal

Bilderfassung mit Kamera

Antriebssteuerung

Drahtlose Datenübertragung mit UDP

Drahtlose Übertragung des Videostreams



Regler ----> Antrieb
Regler ----> Bildverarbeitung

Antrieb ---> UDP
Bildverarbeitung ----> Kamera

*/
 public class Regler
{
    private float spx = 0.0f;
    private Antrieb antrieb;
    private float prozent = 0.0f;  
    private float regeldifferenz = 0.0f;
    
    private float[] e_array = new float[10];  // e_summe = e_array[0] + e_array[1] + ....
    private int index=0;
    private float dt = 0.1f; //Anpassen an frameRate(10); in setup() !!
    private float e_alt = 0.0f;
    public Regler(Antrieb antrieb)
    {
        this.antrieb = antrieb;
    }
    
    public boolean erzeugeStellsignalAusRotbild(int[][] BILD)
    {
      //Schwerpunkt berechnen und einzeichnen
      //und Prozent an roten Pixeln ermitteln
      float gewicht = 0.0f;
      int aktiv=0;
      for(int i=0;i<BILD.length;i++)
      {
         for(int k=0;k<BILD[i].length;k++)
         {
               float wert = (float)BILD[i][k];
               spx += wert*(float)k;
               gewicht+=wert;
               if(wert>0.0f) aktiv++;
               
         }
      }
      if(gewicht>0.0f)
         spx/=gewicht;
      prozent = 100.0f*(float)aktiv/(float)(BILD.length*BILD[0].length);   
      regeldifferenz = 0.0f;
      if(prozent>1.0f && prozent<50.0f)
      {         
         // +/- 1 0=>nicht genug rote Pixel
         // e<0 => links stärker vor
         // e>0 => rechts stärker vor
         regeldifferenz = ((float)(BILD[0].length/2) - spx)/(float)(BILD[0].length/2);
         if(AKTIV)
         {
              float u_links = 0.0f;
              float u_rechts = 0.0f;

              //Implementierung P-Regler, PI-Regler, PID-Regler
              float P = PROPORTIONALE_VERSTAERKUNG;
              float I = INTEGRALE_VERSTAERKUNG;
              float D = DIFFERENTIALE_VERSTAERKUNG;
              float e = regeldifferenz;
              float eD = (e - e_alt)/dt;
              float eI = 0.0f;
              
              for(int i=0;i<e_array.length;i++)
                 eI+=e_array[i];
              eI*=dt;
              float Freg = P*e + I*eI + D*eD;
              
              e_alt = e;
              e_array[index] = e;
              index++;
              index%=e_array.length;
              
              // float Freg = P*e + I*eI + D*eD;
              //ENDE
              if(regeldifferenz<0.0f)
              {
                  u_links  = VORTRIEB;
                  u_rechts = VORTRIEB - Freg;// + PROPORTIONALE_VERSTAERKUNG*(-regeldifferenz);
              }
              else if(regeldifferenz>0.0f)
              {
                  u_links  = VORTRIEB + Freg;// + PROPORTIONALE_VERSTAERKUNG*(regeldifferenz);
                  u_rechts = VORTRIEB;
              }
              
              u_links*=ASYMMETRIE;
              u_rechts*=(2.0f - ASYMMETRIE);
              
              antrieb.fahrt(u_links,u_rechts);
         }
         return true; //Erfolg
      }
      else
      {
         antrieb.fahrt(0.0f,0.0f);
         return false; //kein Erfolg
      }
      
    }
    
    public float holeSchwerpunkt()
    {
         return spx;
    }
    
    public float getProzent()
    {
         return prozent;
    }
    public float getRegeldifferenz()
    {
         return regeldifferenz;
    }
}
public class UDPcomfort
{
   String TEMPERATUR = "";
  
   UDP udp;
   int PORT;
   String IP;
   public UDPcomfort(String IP, int PORT)
   {
      this.IP = IP;
      this.PORT = PORT;
      udp = new UDP( this, 6000 );
      udp.listen( true );
   }
     
   public void send(int nr, int onoffpwm)
   {
    String message  = "C000"; 
    if(nr==0)
    {
         message = "L";
         if(onoffpwm<100) message+="0";
         if(onoffpwm<10) message+="0";
         message+=onoffpwm;
    }
    else if(nr==1)
    {
         message = "R";
         if(onoffpwm<100) message+="0";
         if(onoffpwm<10) message+="0";
         message+=onoffpwm;
    }
    else if(nr==2)
    {
         message = "A";
         message+=onoffpwm;
         if(onoffpwm<100) message+="0";
         if(onoffpwm<10) message+="0";
    }
    else if(nr==3)
    {
         message = "B";
         message+=onoffpwm;
         if(onoffpwm<100) message+="0";
         if(onoffpwm<10) message+="0";
    }
    else if(nr==4)
    {
         message = "C";
         message+=onoffpwm;
         if(onoffpwm<100) message+="0";
         if(onoffpwm<10) message+="0";
    }
    udp.send( message, IP, PORT );
   }

   public String getTemperatur()
   {
       return TEMPERATUR;
   }

 public void receive( byte[] data, String ip, int port ) 
 {  // <-- extended handler
  
  
  // get the "real" message =
  // forget the ";\n" at the end <-- !!! only for a communication with Pd !!!
  data = subset(data, 0, data.length-2);
  String message = new String( data );
  
  // print the result
  println( "receive: \""+message+"\" from "+ip+" on port "+port );
  TEMPERATUR = "receive: \""+message+"\" "+ip+" "+port;
 }     
}


  public void settings() { size(640, 480); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Rearrange" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
